/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => WikidataImporterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  entityIdKey: "wikidata entity id",
  internalLinkPrefix: "db/",
  ignoreCategories: true,
  ignorePropertiesWithTimeRanges: true,
  overwriteExistingProperties: false
};
var WikidataImporterPlugin = class extends import_obsidian.Plugin {
  isString(type) {
    return type === "http://www.w3.org/2001/XMLSchema#string" || type === "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString";
  }
  isInteger(type) {
    return type === "http://www.w3.org/2001/XMLSchema#integer";
  }
  isDecimal(type) {
    return type === "http://www.w3.org/2001/XMLSchema#decimal";
  }
  isDate(type) {
    return type === "http://www.w3.org/2001/XMLSchema#dateTime";
  }
  async getEntity(entityId) {
    let sparqlQuery = `
			SELECT ?propertyLabel ?value ?valueLabel ?valueType ?description WHERE {
				wd:${entityId} ?propUrl ?value .
				?property wikibase:directClaim ?propUrl .
				OPTIONAL { wd:${entityId} schema:description ?description . FILTER (LANG(?description) = "en") }
				BIND(DATATYPE(?value) AS ?valueType) .
		`;
    if (this.settings.ignorePropertiesWithTimeRanges) {
      sparqlQuery += `
				MINUS { ?value p:P580 ?startDateStatement. }
				MINUS { ?value p:P582 ?endDateStatement. }
			`;
    }
    sparqlQuery += `
				SERVICE wikibase:label {
					bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en" .
				}
			}
		`;
    const url = "https://query.wikidata.org/sparql?query=" + encodeURIComponent(sparqlQuery) + "&format=json";
    const response = await (0, import_obsidian.requestUrl)(url);
    const json = await response.json();
    const results = json.results.bindings;
    const ret = {};
    results.forEach((r) => {
      const key = r.propertyLabel.value;
      const value = r.value.value;
      const type = r.valueType ? r.valueType.value : null;
      var valueLabel = r.valueLabel ? r.valueLabel.value : null;
      if (this.settings.ignoreCategories && valueLabel && valueLabel.startsWith("Category:")) {
        return;
      }
      if (this.isDate(type)) {
        valueLabel = value;
      } else if (this.isDecimal(type)) {
        valueLabel = parseFloat(value);
      } else if (this.isInteger(type)) {
        valueLabel = parseInt(value);
      } else if (this.isString(type)) {
        valueLabel = value;
      } else if (value.match(/Q\d+$/) && valueLabel) {
        valueLabel = `[[${this.settings.internalLinkPrefix}${valueLabel}]]`;
      }
      if (ret[key]) {
        ret[key].push(valueLabel);
      } else {
        ret[key] = [valueLabel];
      }
    });
    return {
      id: entityId,
      properties: ret
    };
  }
  async importProperties() {
    var _a;
    let file = this.app.workspace.getActiveFile();
    if (!file) {
      new import_obsidian.Notice("No active file");
      return;
    }
    let frontmatter = ((_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter) || {};
    let entityId = frontmatter[this.settings.entityIdKey];
    if (!entityId || !entityId.startsWith("Q")) {
      new import_obsidian.Notice(
        "To import Wikidata properties, you must define a Wikidata entity ID in the frontmatter"
      );
      return;
    }
    let loading = new import_obsidian.Notice("Loading properties from Wikidata...");
    let entity = null;
    try {
      entity = await this.getEntity(entityId);
    } catch (e) {
      new import_obsidian.Notice(
        `Error fetching properties for entity ${entityId}: ${e}`
      );
      return;
    } finally {
      loading.hide();
    }
    await this.app.fileManager.processFrontMatter(file, (frontmatter2) => {
      let imported = 0;
      let overwritten = 0;
      for (const [key, value] of Object.entries(entity.properties)) {
        if (this.settings.overwriteExistingProperties) {
          if (frontmatter2[key]) {
            overwritten++;
          }
          frontmatter2[key] = value.length === 1 ? value[0] : value;
          imported++;
        } else if (!frontmatter2[key]) {
          frontmatter2[key] = value.length === 1 ? value[0] : value;
          imported++;
        }
      }
      let message = `Imported ${imported} properties from Wikidata entity ${entityId}`;
      if (overwritten > 0) {
        message += ` (overwrote ${overwritten} existing properties)`;
      }
      new import_obsidian.Notice(message);
    });
  }
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "import-properties-for-active-file",
      name: "Import properties for active file",
      editorCallback: this.importProperties.bind(this)
    });
    this.addSettingTab(new WikidataImporterSettingsTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var WikidataImporterSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Wikidata entity ID key").setDesc("The frontmatter key to use for the Wikidata entity ID").addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.entityIdKey).setValue(this.plugin.settings.entityIdKey).onChange(async (value) => {
        this.plugin.settings.entityIdKey = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Internal link prefix").setDesc(
      "The prefix to use for internal links to Wikidata entities"
    ).addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.internalLinkPrefix).setValue(this.plugin.settings.internalLinkPrefix).onChange(async (value) => {
        this.plugin.settings.internalLinkPrefix = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Ignore categories").setDesc(
      "If checked, categories will not be imported as properties"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.ignoreCategories).onChange(async (value) => {
        this.plugin.settings.ignoreCategories = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Ignore properties with time ranges").setDesc(
      "If checked, properties with time ranges will not be imported"
    ).addToggle(
      (toggle) => toggle.setValue(
        this.plugin.settings.ignorePropertiesWithTimeRanges
      ).onChange(async (value) => {
        this.plugin.settings.ignorePropertiesWithTimeRanges = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Overwrite existing properties").setDesc(
      "If checked, existing properties will be overwritten when importing"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.overwriteExistingProperties).onChange(async (value) => {
        this.plugin.settings.overwriteExistingProperties = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
